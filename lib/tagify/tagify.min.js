/**
 * Tagify (v 4.12.0) - tags input component
 * By Yair Even-Or
 * https://github.com/yairEO/tagify
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * THE SOFTWARE IS NOT PERMISSIBLE TO BE SOLD.
 */

!(function (t, e) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = e())
    : typeof define === "function" && define.amd
    ? define(e)
    : ((t = typeof globalThis !== "undefined" ? globalThis : t || self).Tagify =
        e());
})(this, function () {
  "use strict";
  function t(t, e) {
    const i = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      let s = Object.getOwnPropertySymbols(t);
      e &&
        (s = s.filter(function (e) {
          return Object.getOwnPropertyDescriptor(t, e).enumerable;
        })),
        i.push.apply(i, s);
    }
    return i;
  }
  function e(e) {
    for (let s = 1; s < arguments.length; s++) {
      var a = arguments[s] != null ? arguments[s] : {};
      s % 2
        ? t(Object(a), !0).forEach(function (t) {
            i(e, t, a[t]);
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(a))
        : t(Object(a)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(a, t));
          });
    }
    return e;
  }
  function i(t, e, i) {
    return (
      e in t
        ? Object.defineProperty(t, e, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (t[e] = i),
      t
    );
  }
  const s = (t, e, i, s) => (
    (t = "" + t),
    (e = "" + e),
    s && ((t = t.trim()), (e = e.trim())),
    i ? t == e : t.toLowerCase() == e.toLowerCase()
  );
  const a = (t, e) => t && Array.isArray(t) && t.map((t) => n(t, e));
  function n(t, e) {
    let i;
    const s = {};
    for (i in t) e.indexOf(i) < 0 && (s[i] = t[i]);
    return s;
  }
  function o(t) {
    const e = document.createElement("div");
    return t.replace(/\&#?[0-9a-z]+;/gi, function (t) {
      return (e.innerHTML = t), e.innerText;
    });
  }
  function r(t) {
    return new DOMParser().parseFromString(
      t.trim(),
      "text/html"
    ).body.firstElementChild;
  }
  function l(t, e) {
    for (e = e || "previous"; (t = t[e + "Sibling"]); )
      if (t.nodeType == 3) return t;
  }
  function d(t) {
    return typeof t === "string"
      ? t
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/`|'/g, "&#039;")
      : t;
  }
  function h(t) {
    const e = Object.prototype.toString.call(t).split(" ")[1].slice(0, -1);
    return (
      t === Object(t) &&
      e != "Array" &&
      e != "Function" &&
      e != "RegExp" &&
      e != "HTMLUnknownElement"
    );
  }
  function g(t, e, i) {
    function s(t, e) {
      for (const i in e)
        if (e.hasOwnProperty(i)) {
          if (h(e[i])) {
            h(t[i]) ? s(t[i], e[i]) : (t[i] = Object.assign({}, e[i]));
            continue;
          }
          if (Array.isArray(e[i])) {
            t[i] = Object.assign([], e[i]);
            continue;
          }
          t[i] = e[i];
        }
    }
    return t instanceof Object || (t = {}), s(t, e), i && s(t, i), t;
  }
  function p() {
    const t = [];
    const e = {};
    for (const i of arguments)
      for (const s of i)
        h(s)
          ? e[s.value] || (t.push(s), (e[s.value] = 1))
          : t.includes(s) || t.push(s);
    return t;
  }
  function c(t) {
    return String.prototype.normalize
      ? typeof t === "string"
        ? t.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        : void 0
      : t;
  }
  const u = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
  function m() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (t) =>
      (
        t ^
        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (t / 4)))
      ).toString(16)
    );
  }
  function v(t) {
    return (
      t && t.classList && t.classList.contains(this.settings.classNames.tag)
    );
  }
  const f = {
    delimiters: ",",
    pattern: null,
    tagTextProp: "value",
    maxTags: 1 / 0,
    callbacks: {},
    addTagOnBlur: !0,
    duplicates: !1,
    whitelist: [],
    blacklist: [],
    enforceWhitelist: !1,
    userInput: !0,
    keepInvalidTags: !1,
    mixTagsAllowedAfter: /,|\.|\:|\s/,
    mixTagsInterpolator: ["[[", "]]"],
    backspace: !0,
    skipInvalid: !1,
    pasteAsTags: !0,
    editTags: { clicks: 2, keepInvalid: !0 },
    transformTag: () => {},
    trim: !0,
    a11y: { focusableTags: !1 },
    mixMode: { insertAfterTag: " " },
    autoComplete: { enabled: !0, rightKey: !1 },
    classNames: {
      namespace: "tagify",
      mixMode: "tagify--mix",
      selectMode: "tagify--select",
      input: "tagify__input",
      focus: "tagify--focus",
      tagNoAnimation: "tagify--noAnim",
      tagInvalid: "tagify--invalid",
      tagNotAllowed: "tagify--notAllowed",
      scopeLoading: "tagify--loading",
      hasMaxTags: "tagify--hasMaxTags",
      hasNoTags: "tagify--noTags",
      empty: "tagify--empty",
      inputInvalid: "tagify__input--invalid",
      dropdown: "tagify__dropdown",
      dropdownWrapper: "tagify__dropdown__wrapper",
      dropdownHeader: "tagify__dropdown__header",
      dropdownFooter: "tagify__dropdown__footer",
      dropdownItem: "tagify__dropdown__item",
      dropdownItemActive: "tagify__dropdown__item--active",
      dropdownInital: "tagify__dropdown--initial",
      tag: "tagify__tag",
      tagText: "tagify__tag-text",
      tagX: "tagify__tag__removeBtn",
      tagLoading: "tagify__tag--loading",
      tagEditing: "tagify__tag--editable",
      tagFlash: "tagify__tag--flash",
      tagHide: "tagify__tag--hide",
    },
    dropdown: {
      classname: "",
      enabled: 2,
      maxItems: 10,
      searchKeys: ["value", "searchBy"],
      fuzzySearch: !0,
      caseSensitive: !1,
      accentedSearch: !0,
      highlightFirst: !1,
      closeOnSelect: !0,
      clearOnSelect: !0,
      position: "all",
      appendTarget: null,
    },
    hooks: {
      beforeRemoveTag: () => Promise.resolve(),
      beforePaste: () => Promise.resolve(),
      suggestionClick: () => Promise.resolve(),
    },
  };
  function T() {
    this.dropdown = {};
    for (const t in this._dropdown)
      this.dropdown[t] =
        typeof this._dropdown[t] === "function"
          ? this._dropdown[t].bind(this)
          : this._dropdown[t];
    this.dropdown.refs();
  }
  const w = {
    refs() {
      (this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings])),
        (this.DOM.dropdown.content = this.DOM.dropdown.querySelector(
          "[data-selector='tagify-dropdown-wrapper']"
        ));
    },
    show(t) {
      let e;
      let i;
      let a;
      const n = this.settings;
      const o = n.mode == "mix" && !n.enforceWhitelist;
      const r = !n.whitelist || !n.whitelist.length;
      const l = n.dropdown.position == "manual";
      if (
        ((t = void 0 === t ? this.state.inputText : t),
        (!r || o || n.templates.dropdownItemNoMatch) &&
          !1 !== n.dropdown.enable &&
          !this.state.isLoading)
      ) {
        if (
          (clearTimeout(this.dropdownHide__bindEventsTimeout),
          (this.suggestedListItems = this.dropdown.filterListItems(t)),
          t &&
            !this.suggestedListItems.length &&
            (this.trigger("dropdown:noMatch", t),
            n.templates.dropdownItemNoMatch &&
              (a = n.templates.dropdownItemNoMatch.call(this, { value: t }))),
          !a)
        ) {
          if (this.suggestedListItems.length)
            t &&
              o &&
              !this.state.editing.scope &&
              !s(this.suggestedListItems[0].value, t) &&
              this.suggestedListItems.unshift({ value: t });
          else {
            if (!t || !o || this.state.editing.scope)
              return (
                this.input.autocomplete.suggest.call(this),
                void this.dropdown.hide()
              );
            this.suggestedListItems = [{ value: t }];
          }
          (i = "" + (h((e = this.suggestedListItems[0])) ? e.value : e)),
            n.autoComplete &&
              i &&
              i.indexOf(t) == 0 &&
              this.input.autocomplete.suggest.call(this, e);
        }
        this.dropdown.fill(a),
          n.dropdown.highlightFirst &&
            this.dropdown.highlightOption(
              this.DOM.dropdown.content.children[0]
            ),
          this.state.dropdown.visible ||
            setTimeout(this.dropdown.events.binding.bind(this)),
          (this.state.dropdown.visible = t || !0),
          (this.state.dropdown.query = t),
          this.setStateSelection(),
          l ||
            setTimeout(() => {
              this.dropdown.position(), this.dropdown.render();
            }),
          setTimeout(() => {
            this.trigger("dropdown:show", this.DOM.dropdown);
          });
      }
    },
    hide(t) {
      const e = this.DOM;
      const i = e.scope;
      const s = e.dropdown;
      const a = this.settings.dropdown.position == "manual" && !t;
      if (s && document.body.contains(s) && !a)
        return (
          window.removeEventListener("resize", this.dropdown.position),
          this.dropdown.events.binding.call(this, !1),
          i.setAttribute("aria-expanded", !1),
          s.parentNode.removeChild(s),
          setTimeout(() => {
            this.state.dropdown.visible = !1;
          }, 100),
          (this.state.dropdown.query =
            this.state.ddItemData =
            this.state.ddItemElm =
            this.state.selection =
              null),
          this.state.tag &&
            this.state.tag.value.length &&
            (this.state.flaggedTags[this.state.tag.baseOffset] =
              this.state.tag),
          this.trigger("dropdown:hide", s),
          this
        );
    },
    toggle(t) {
      this.dropdown[this.state.dropdown.visible && !t ? "hide" : "show"]();
    },
    render() {
      let t;
      let e;
      let i;
      const s =
        ((t = this.DOM.dropdown),
        ((i = t.cloneNode(!0)).style.cssText =
          "position:fixed; top:-9999px; opacity:0"),
        document.body.appendChild(i),
        (e = i.clientHeight),
        i.parentNode.removeChild(i),
        e);
      const a = this.settings;
      return typeof a.dropdown.enabled === "number" && a.dropdown.enabled >= 0
        ? (this.DOM.scope.setAttribute("aria-expanded", !0),
          document.body.contains(this.DOM.dropdown) ||
            (this.DOM.dropdown.classList.add(a.classNames.dropdownInital),
            this.dropdown.position(s),
            a.dropdown.appendTarget.appendChild(this.DOM.dropdown),
            setTimeout(() =>
              this.DOM.dropdown.classList.remove(a.classNames.dropdownInital)
            )),
          this)
        : this;
    },
    fill(t) {
      t =
        typeof t === "string"
          ? t
          : this.dropdown.createListHTML(t || this.suggestedListItems);
      let e;
      const i = this.settings.templates.dropdownContent.call(this, t);
      this.DOM.dropdown.content.innerHTML = (e = i)
        ? e
            .replace(/\>[\r\n ]+\</g, "><")
            .replace(/(<.*?>)|\s+/g, (t, e) => e || " ")
        : "";
    },
    refilter(t) {
      (t = t || this.state.dropdown.query || ""),
        (this.suggestedListItems = this.dropdown.filterListItems(t)),
        this.dropdown.fill(),
        this.suggestedListItems.length || this.dropdown.hide(),
        this.trigger("dropdown:updated", this.DOM.dropdown);
    },
    position(t) {
      const e = this.settings.dropdown;
      if (e.position != "manual") {
        let i;
        let s;
        let a;
        let n;
        let o;
        let r;
        const l = this.DOM.dropdown;
        let d = e.placeAbove;
        const h = document.documentElement.clientHeight;
        const g =
          Math.max(
            document.documentElement.clientWidth || 0,
            window.innerWidth || 0
          ) > 480
            ? e.position
            : "all";
        const p = this.DOM[g == "input" ? "input" : "scope"];
        (t = t || l.clientHeight),
          this.state.dropdown.visible &&
            (g == "text"
              ? ((a = (i = this.getCaretGlobalPosition()).bottom),
                (s = i.top),
                (n = i.left),
                (o = "auto"))
              : ((r = (function (t) {
                  for (var e = 0, i = 0; t; )
                    (e += t.offsetLeft || 0),
                      (i += t.offsetTop || 0),
                      (t = t.parentNode);
                  return { left: e, top: i };
                })(this.settings.dropdown.appendTarget)),
                (s = (i = p.getBoundingClientRect()).top - r.top),
                (a = i.bottom - 1 - r.top),
                (n = i.left - r.left),
                (o = i.width + "px")),
            (s = Math.floor(s)),
            (a = Math.ceil(a)),
            (d = void 0 === d ? h - i.bottom < t : d),
            (l.style.cssText =
              "left:" +
              (n + window.pageXOffset) +
              "px; width:" +
              o +
              ";" +
              (d
                ? "top: " + (s + window.pageYOffset) + "px"
                : "top: " + (a + window.pageYOffset) + "px")),
            l.setAttribute("placement", d ? "top" : "bottom"),
            l.setAttribute("position", g));
      }
    },
    events: {
      binding(t = !0) {
        const e = this.dropdown.events.callbacks;
        const i = (this.listeners.dropdown = this.listeners.dropdown || {
          position: this.dropdown.position.bind(this),
          onKeyDown: e.onKeyDown.bind(this),
          onMouseOver: e.onMouseOver.bind(this),
          onMouseLeave: e.onMouseLeave.bind(this),
          onClick: e.onClick.bind(this),
          onScroll: e.onScroll.bind(this),
        });
        const s = t ? "addEventListener" : "removeEventListener";
        this.settings.dropdown.position != "manual" &&
          (window[s]("resize", i.position), window[s]("keydown", i.onKeyDown)),
          this.DOM.dropdown[s]("mouseover", i.onMouseOver),
          this.DOM.dropdown[s]("mouseleave", i.onMouseLeave),
          this.DOM.dropdown[s]("mousedown", i.onClick),
          this.DOM.dropdown.content[s]("scroll", i.onScroll);
      },
      callbacks: {
        onKeyDown(t) {
          let e = this.DOM.dropdown.querySelector(
            this.settings.classNames.dropdownItemActiveSelector
          );
          let i = this.dropdown.getSuggestionDataByNode(e);
          switch (t.key) {
            case "ArrowDown":
            case "ArrowUp":
            case "Down":
            case "Up":
              var s;
              t.preventDefault(),
                e &&
                  (e =
                    e[
                      (t.key == "ArrowUp" || t.key == "Up"
                        ? "previous"
                        : "next") + "ElementSibling"
                    ]),
                e ||
                  ((s = this.DOM.dropdown.content.children),
                  (e =
                    s[t.key == "ArrowUp" || t.key == "Up" ? s.length - 1 : 0])),
                (i = this.dropdown.getSuggestionDataByNode(e)),
                this.dropdown.highlightOption(e, !0);
              break;
            case "Escape":
            case "Esc":
              this.dropdown.hide();
              break;
            case "ArrowRight":
              if (this.state.actions.ArrowLeft) return;
            case "Tab":
              if (
                this.settings.mode != "mix" &&
                e &&
                !this.settings.autoComplete.rightKey &&
                !this.state.editing
              ) {
                t.preventDefault();
                const a = this.dropdown.getMappedValue(i);
                return this.input.autocomplete.set.call(this, a), !1;
              }
              return !0;
            case "Enter":
              t.preventDefault(),
                this.settings.hooks
                  .suggestionClick(t, {
                    tagify: this,
                    tagData: i,
                    suggestionElm: e,
                  })
                  .then(() => {
                    if (e) return this.dropdown.selectOption(e);
                    this.dropdown.hide(),
                      this.settings.mode != "mix" &&
                        this.addTags(this.state.inputText.trim(), !0);
                  })
                  .catch((t) => t);
              break;
            case "Backspace": {
              if (this.settings.mode == "mix" || this.state.editing.scope)
                return;
              const t = this.input.raw.call(this);
              (t != "" && t.charCodeAt(0) != 8203) ||
                (!0 === this.settings.backspace
                  ? this.removeTags()
                  : this.settings.backspace == "edit" &&
                    setTimeout(this.editTag.bind(this), 0));
            }
          }
        },
        onMouseOver(t) {
          const e = t.target.closest(
            this.settings.classNames.dropdownItemSelector
          );
          e && this.dropdown.highlightOption(e);
        },
        onMouseLeave(t) {
          this.dropdown.highlightOption();
        },
        onClick(t) {
          if (
            t.button == 0 &&
            t.target != this.DOM.dropdown &&
            t.target != this.DOM.dropdown.content
          ) {
            const e = t.target.closest(
              this.settings.classNames.dropdownItemSelector
            );
            const i = this.dropdown.getSuggestionDataByNode(e);
            (this.state.actions.selectOption = !0),
              setTimeout(() => (this.state.actions.selectOption = !1), 50),
              this.settings.hooks
                .suggestionClick(t, {
                  tagify: this,
                  tagData: i,
                  suggestionElm: e,
                })
                .then(() => {
                  e ? this.dropdown.selectOption(e) : this.dropdown.hide();
                })
                .catch((t) => console.warn(t));
          }
        },
        onScroll(t) {
          const e = t.target;
          const i =
            (e.scrollTop / (e.scrollHeight - e.parentNode.clientHeight)) * 100;
          this.trigger("dropdown:scroll", { percentage: Math.round(i) });
        },
      },
    },
    getSuggestionDataByNode(t) {
      const e = t ? +t.getAttribute("tagifySuggestionIdx") : -1;
      return this.suggestedListItems[e] || null;
    },
    highlightOption(t, e) {
      let i;
      const s = this.settings.classNames.dropdownItemActive;
      if (
        (this.state.ddItemElm &&
          (this.state.ddItemElm.classList.remove(s),
          this.state.ddItemElm.removeAttribute("aria-selected")),
        !t)
      )
        return (
          (this.state.ddItemData = null),
          (this.state.ddItemElm = null),
          void this.input.autocomplete.suggest.call(this)
        );
      (i = this.suggestedListItems[this.getNodeIndex(t)]),
        (this.state.ddItemData = i),
        (this.state.ddItemElm = t),
        t.classList.add(s),
        t.setAttribute("aria-selected", !0),
        e &&
          (t.parentNode.scrollTop =
            t.clientHeight + t.offsetTop - t.parentNode.clientHeight),
        this.settings.autoComplete &&
          (this.input.autocomplete.suggest.call(this, i),
          this.dropdown.position());
    },
    selectOption(t) {
      const e = this.settings.dropdown;
      const i = e.clearOnSelect;
      const s = e.closeOnSelect;
      if (!t)
        return (
          this.addTags(this.state.inputText, !0),
          void (s && this.dropdown.hide())
        );
      const a = t.getAttribute("tagifySuggestionIdx");
      const n = this.suggestedListItems[+a];
      this.trigger("dropdown:select", { data: n, elm: t }),
        a && n
          ? (this.state.editing
              ? this.onEditTagDone(
                  null,
                  g({ __isValid: !0 }, this.normalizeTags([n])[0])
                )
              : this[this.settings.mode == "mix" ? "addMixTags" : "addTags"](
                  [n],
                  i
                ),
            this.DOM.input.parentNode &&
              (setTimeout(() => {
                this.DOM.input.focus(), this.toggleFocusClass(!0);
              }),
              s
                ? setTimeout(this.dropdown.hide.bind(this))
                : this.dropdown.refilter()))
          : this.dropdown.hide();
    },
    selectAll(t) {
      (this.suggestedListItems.length = 0),
        this.dropdown.hide(),
        this.dropdown.filterListItems("");
      let e = this.dropdown.filterListItems("");
      return (
        t || (e = this.state.dropdown.suggestions), this.addTags(e, !0), this
      );
    },
    filterListItems(t, e) {
      let i;
      let s;
      let a;
      let n;
      let o;
      const r = this.settings;
      const l = r.dropdown;
      let d =
        ((e = e || {}),
        (t =
          r.mode == "select" &&
          this.value.length &&
          this.value[0][r.tagTextProp] == t
            ? ""
            : t),
        []);
      const g = [];
      const p = r.whitelist;
      const u = l.maxItems >= 0 ? l.maxItems : 1 / 0;
      const m = l.searchKeys;
      let v = 0;
      if (!t || !m.length)
        return (
          (d = r.duplicates
            ? p
            : p.filter((t) => !this.isTagDuplicate(h(t) ? t.value : t))),
          (this.state.dropdown.suggestions = d),
          d.slice(0, u)
        );
      function f(t, e) {
        return e
          .toLowerCase()
          .split(" ")
          .every((e) => t.includes(e.toLowerCase()));
      }
      for (
        o = l.caseSensitive ? "" + t : ("" + t).toLowerCase();
        v < p.length;
        v++
      ) {
        let t, u;
        i = p[v] instanceof Object ? p[v] : { value: p[v] };
        const T = !Object.keys(i).some((t) => m.includes(t)) ? ["value"] : m;
        l.fuzzySearch && !e.exact
          ? ((a = T.reduce((t, e) => t + " " + (i[e] || ""), "")
              .toLowerCase()
              .trim()),
            l.accentedSearch && ((a = c(a)), (o = c(o))),
            (t = a.indexOf(o) == 0),
            (u = a === o),
            (s = f(a, o)))
          : ((t = !0),
            (s = T.some((t) => {
              let s = "" + (i[t] || "");
              return (
                l.accentedSearch && ((s = c(s)), (o = c(o))),
                l.caseSensitive || (s = s.toLowerCase()),
                (u = s === o),
                e.exact ? s === o : s.indexOf(o) == 0
              );
            }))),
          (n = !r.duplicates && this.isTagDuplicate(h(i) ? i.value : i)),
          s &&
            !n &&
            (u && t
              ? g.push(i)
              : l.sortby == "startsWith" && t
              ? d.unshift(i)
              : d.push(i));
      }
      return (
        (this.state.dropdown.suggestions = g.concat(d)),
        typeof l.sortby === "function"
          ? l.sortby(g.concat(d), o)
          : g.concat(d).slice(0, u)
      );
    },
    getMappedValue(t) {
      const e = this.settings.dropdown.mapValueTo;
      return e ? (typeof e === "function" ? e(t) : t[e] || t.value) : t.value;
    },
    createListHTML(t) {
      return g([], t)
        .map((t, e) => {
          (typeof t !== "string" && typeof t !== "number") ||
            (t = { value: t });
          const i = this.dropdown.getMappedValue(t);
          t.value = typeof i === "string" ? d(i) : i;
          let s = this.settings.templates.dropdownItem.apply(this, [t, this]);
          return (s = s
            .replace(/\s*tagifySuggestionIdx=(["'])(.*?)\1/gim, "")
            .replace(">", ` tagifySuggestionIdx="${e}">`));
        })
        .join("");
    },
  };
  const b = "@yaireo/tagify/";
  let y;
  const x = {
    empty: "empty",
    exceed: "number of tags exceeded",
    pattern: "pattern mismatch",
    duplicate: "already exists",
    notAllowed: "not allowed",
  };
  const D = {
    wrapper: (t, e) =>
      `<tags class="${e.classNames.namespace} ${
        e.mode ? `${e.classNames[e.mode + "Mode"]}` : ""
      } ${t.className}"\n                    ${
        e.readonly ? "readonly" : ""
      }\n                    ${
        e.disabled ? "disabled" : ""
      }\n                    ${
        e.required ? "required" : ""
      }\n                    ${
        e.mode === "select" ? "spellcheck='false'" : ""
      }\n                    tabIndex="-1">\n            <span ${
        !e.readonly && e.userInput ? "contenteditable" : ""
      } tabIndex="0" data-placeholder="${
        e.placeholder || "&#8203;"
      }" aria-placeholder="${e.placeholder || ""}"\n                class="${
        e.classNames.input
      }"\n                role="textbox"\n                aria-autocomplete="both"\n                aria-multiline="${
        e.mode == "mix"
      }"></span>\n                &#8203;\n        </tags>`,
    tag(t, e) {
      const i = this.settings;
      return `<tag title="${
        t.title || t.value
      }"\n                    contenteditable='false'\n                    spellcheck='false'\n                    tabIndex="${
        i.a11y.focusableTags ? 0 : -1
      }"\n                    class="${i.classNames.tag} ${
        t.class || ""
      }"\n                    ${this.getAttributes(
        t
      )}>\n            <x title='' class="${
        i.classNames.tagX
      }" role='button' aria-label='remove tag'></x>\n            <div>\n                <span class="${
        i.classNames.tagText
      }">${
        t[i.tagTextProp] || t.value
      }</span>\n            </div>\n        </tag>`;
    },
    dropdown(t) {
      const e = t.dropdown;
      const i = e.position == "manual";
      const s = `${t.classNames.dropdown}`;
      return `<div class="${i ? "" : s} ${
        e.classname
      }" role="listbox" aria-labelledby="dropdown">\n                    <div data-selector='tagify-dropdown-wrapper' class="${
        t.classNames.dropdownWrapper
      }"></div>\n                </div>`;
    },
    dropdownContent(t) {
      const e = this.settings;
      const i = this.state.dropdown.suggestions;
      return `\n            ${e.templates.dropdownHeader.call(
        this,
        i
      )}\n            ${t}\n            ${e.templates.dropdownFooter.call(
        this,
        i
      )}\n        `;
    },
    dropdownItem(t, e) {
      return `<div ${this.getAttributes(t)}\n                    class='${
        this.settings.classNames.dropdownItem
      } ${
        t.class ? t.class : ""
      }'\n                    tabindex="0"\n                    role="option">${
        t.value
      }</div>`;
    },
    dropdownHeader: (t) => "",
    dropdownFooter(t) {
      const e = t.length - this.settings.dropdown.maxItems;
      return e > 0
        ? `<footer data-selector='tagify-suggestions-footer' class="${this.settings.classNames.dropdownFooter}">\n                ${e} more items. Refine your search.\n            </footer>`
        : "";
    },
    dropdownItemNoMatch: null,
  };
  const O = {
    customBinding() {
      this.customEventsList.forEach((t) => {
        this.on(t, this.settings.callbacks[t]);
      });
    },
    binding(t = !0) {
      let e;
      const i = this.events.callbacks;
      const s = t ? "addEventListener" : "removeEventListener";
      if (!this.state.mainEvents || !t) {
        for (const a in ((this.state.mainEvents = t),
        t &&
          !this.listeners.main &&
          (this.events.bindGlobal.call(this),
          this.settings.isJQueryPlugin &&
            jQuery(this.DOM.originalInput).on(
              "tagify.removeAllTags",
              this.removeAllTags.bind(this)
            )),
        (e = this.listeners.main =
          this.listeners.main || {
            focus: ["input", i.onFocusBlur.bind(this)],
            keydown: ["input", i.onKeydown.bind(this)],
            click: ["scope", i.onClickScope.bind(this)],
            dblclick: ["scope", i.onDoubleClickScope.bind(this)],
            paste: ["input", i.onPaste.bind(this)],
            drop: ["input", i.onDrop.bind(this)],
          })))
          this.DOM[e[a][0]][s](a, e[a][1]);
        clearInterval(this.listeners.main.originalInputValueObserverInterval),
          (this.listeners.main.originalInputValueObserverInterval = setInterval(
            i.observeOriginalInputValue.bind(this),
            500
          ));
        const n =
          this.listeners.main.inputMutationObserver ||
          new MutationObserver(i.onInputDOMChange.bind(this));
        n && n.disconnect(),
          this.settings.mode == "mix" &&
            n.observe(this.DOM.input, { childList: !0 });
      }
    },
    bindGlobal(t) {
      let e;
      const i = this.events.callbacks;
      const s = t ? "removeEventListener" : "addEventListener";
      if (t || !this.listeners.global)
        for (e of ((this.listeners.global = (this.listeners &&
          this.listeners.global) || [
          {
            type: this.isIE ? "keydown" : "input",
            target: this.DOM.input,
            cb: i[this.isIE ? "onInputIE" : "onInput"].bind(this),
          },
          { type: "keydown", target: window, cb: i.onWindowKeyDown.bind(this) },
          {
            type: "blur",
            target: this.DOM.input,
            cb: i.onFocusBlur.bind(this),
          },
        ]),
        this.listeners.global))
          e.target[s](e.type, e.cb);
    },
    unbindGlobal() {
      this.events.bindGlobal.call(this, !0);
    },
    callbacks: {
      onFocusBlur(t) {
        let e = t.target ? this.trim(t.target.textContent) : "";
        const i = this.settings;
        const s = t.type;
        const a = i.dropdown.enabled >= 0;
        const n = { relatedTarget: t.relatedTarget };
        const o =
          this.state.actions.selectOption && (a || !i.dropdown.closeOnSelect);
        const r = this.state.actions.addNew && a;
        const l =
          t.relatedTarget &&
          v.call(this, t.relatedTarget) &&
          this.DOM.scope.contains(t.relatedTarget);
        if (s == "blur") {
          if (t.relatedTarget === this.DOM.scope)
            return this.dropdown.hide(), void this.DOM.input.focus();
          this.postUpdate(), this.triggerChangeEvent();
        }
        if (!o && !r)
          if (
            ((this.state.hasFocus = s == "focus" && +new Date()),
            this.toggleFocusClass(this.state.hasFocus),
            i.mode != "mix")
          ) {
            if (s == "focus")
              return (
                this.trigger("focus", n),
                void (
                  (i.dropdown.enabled !== 0 && i.userInput) ||
                  this.dropdown.show(this.value.length ? "" : void 0)
                )
              );
            if (s == "blur") {
              let d, h;
              this.trigger("blur", n), this.loading(!1);
              const t = i.enforceWhitelist
                ? !!this.getWhitelistItem(
                    (d = this.value) === null ||
                      void 0 === d ||
                      (h = d[0]) === null ||
                      void 0 === h
                      ? void 0
                      : h.value
                  )
                : i.keepInvalidTags;
              this.settings.mode == "select" && l && (e = ""),
                this.settings.mode !== "select" &&
                  e &&
                  !this.state.actions.selectOption &&
                  i.addTagOnBlur &&
                  this.addTags(e, !0),
                this.settings.mode != "select" || (e && t) || this.removeTags();
            }
            this.DOM.input.removeAttribute("style"), this.dropdown.hide();
          } else
            s == "focus"
              ? this.trigger("focus", n)
              : t.type == "blur" &&
                (this.trigger("blur", n),
                this.loading(!1),
                this.dropdown.hide(),
                (this.state.dropdown.visible = void 0),
                this.setStateSelection());
      },
      onWindowKeyDown(t) {
        let e;
        const i = document.activeElement;
        if (v.call(this, i) && this.DOM.scope.contains(document.activeElement))
          switch (((e = i.nextElementSibling), t.key)) {
            case "Backspace":
              this.settings.readonly ||
                (this.removeTags(i), (e || this.DOM.input).focus());
              break;
            case "Enter":
              setTimeout(this.editTag.bind(this), 0, i);
          }
      },
      onKeydown(t) {
        const e = this.settings;
        e.mode == "select" &&
          e.enforceWhitelist &&
          this.value.length &&
          t.key != "Tab" &&
          t.preventDefault();
        const i = this.trim(t.target.textContent);
        if (
          (this.trigger("keydown", { originalEvent: this.cloneEvent(t) }),
          e.mode == "mix")
        ) {
          switch (t.key) {
            case "Left":
            case "ArrowLeft":
              this.state.actions.ArrowLeft = !0;
              break;
            case "Delete":
            case "Backspace":
              if (this.state.editing) return;
              var s;
              var a;
              var n;
              var r = document.getSelection();
              var d =
                t.key == "Delete" &&
                r.anchorOffset == (r.anchorNode.length || 0);
              var h = r.anchorNode.previousSibling;
              var g =
                r.anchorNode.nodeType == 1 ||
                (!r.anchorOffset &&
                  h &&
                  h.nodeType == 1 &&
                  r.anchorNode.previousSibling);
              var p = o(this.DOM.input.innerHTML);
              var c = this.getTagElms();
              if (e.backspace == "edit" && g)
                return (
                  (s =
                    r.anchorNode.nodeType == 1
                      ? null
                      : r.anchorNode.previousElementSibling),
                  setTimeout(this.editTag.bind(this), 0, s),
                  void t.preventDefault()
                );
              if (u() && g)
                return (
                  (n = l(g)),
                  g.hasAttribute("readonly") || g.remove(),
                  this.DOM.input.focus(),
                  void setTimeout(() => {
                    this.placeCaretAfterNode(n), this.DOM.input.click();
                  })
                );
              if (r.anchorNode.nodeName == "BR") return;
              if (
                ((d || g) && r.anchorNode.nodeType == 1
                  ? (a =
                      r.anchorOffset == 0
                        ? d
                          ? c[0]
                          : null
                        : c[r.anchorOffset - 1])
                  : d
                  ? (a = r.anchorNode.nextElementSibling)
                  : g && (a = g),
                r.anchorNode.nodeType == 3 &&
                  !r.anchorNode.nodeValue &&
                  r.anchorNode.previousElementSibling &&
                  t.preventDefault(),
                (g || d) && !e.backspace)
              )
                return void t.preventDefault();
              if (
                r.type != "Range" &&
                !r.anchorOffset &&
                r.anchorNode == this.DOM.input &&
                t.key != "Delete"
              )
                return void t.preventDefault();
              if (r.type != "Range" && a && a.hasAttribute("readonly"))
                return void this.placeCaretAfterNode(l(a));
              clearTimeout(y),
                (y = setTimeout(() => {
                  const t = document.getSelection();
                  const e = o(this.DOM.input.innerHTML);
                  const i = !d && t.anchorNode.previousSibling;
                  if (e.length >= p.length && i)
                    if (v.call(this, i) && !i.hasAttribute("readonly")) {
                      if (
                        (this.removeTags(i),
                        this.fixFirefoxLastTagNoCaret(),
                        this.DOM.input.children.length == 2 &&
                          this.DOM.input.children[1].tagName == "BR")
                      )
                        return (
                          (this.DOM.input.innerHTML = ""),
                          (this.value.length = 0),
                          !0
                        );
                    } else i.remove();
                  this.value = [].map
                    .call(c, (t, e) => {
                      const i = this.tagData(t);
                      if (t.parentNode || i.readonly) return i;
                      this.trigger("remove", { tag: t, index: e, data: i });
                    })
                    .filter((t) => t);
                }, 20));
          }
          return !0;
        }
        switch (t.key) {
          case "Backspace":
            e.mode == "select" && e.enforceWhitelist && this.value.length
              ? this.removeTags()
              : (this.state.dropdown.visible &&
                  e.dropdown.position != "manual") ||
                (t.target.textContent != "" && i.charCodeAt(0) != 8203) ||
                (!0 === e.backspace
                  ? this.removeTags()
                  : e.backspace == "edit" &&
                    setTimeout(this.editTag.bind(this), 0));
            break;
          case "Esc":
          case "Escape":
            if (this.state.dropdown.visible) return;
            t.target.blur();
            break;
          case "Down":
          case "ArrowDown":
            this.state.dropdown.visible || this.dropdown.show();
            break;
          case "ArrowRight": {
            const t = this.state.inputSuggestion || this.state.ddItemData;
            if (t && e.autoComplete.rightKey) return void this.addTags([t], !0);
            break;
          }
          case "Tab": {
            const s = e.mode == "select";
            if (!i || s) return !0;
            t.preventDefault();
          }
          case "Enter":
            if (this.state.dropdown.visible || t.keyCode == 229) return;
            t.preventDefault(),
              setTimeout(() => {
                this.state.actions.selectOption || this.addTags(i, !0);
              });
        }
      },
      onInput(t) {
        if ((this.postUpdate(), this.settings.mode == "mix"))
          return this.events.callbacks.onMixTagsInput.call(this, t);
        const e = this.input.normalize.call(this);
        const i = e.length >= this.settings.dropdown.enabled;
        const s = { value: e, inputElm: this.DOM.input };
        (s.isValid = this.validateTag({ value: e })),
          this.state.inputText != e &&
            (this.input.set.call(this, e, !1),
            e.search(this.settings.delimiters) != -1
              ? this.addTags(e) && this.input.set.call(this)
              : this.settings.dropdown.enabled >= 0 &&
                this.dropdown[i ? "show" : "hide"](e),
            this.trigger("input", s));
      },
      onMixTagsInput(t) {
        let e;
        let i;
        let s;
        let a;
        let n;
        let o;
        let r;
        let l;
        const d = this.settings;
        const h = this.value.length;
        const p = this.getTagElms();
        const c = document.createDocumentFragment();
        let m = window.getSelection().getRangeAt(0);
        const v = [].map.call(p, (t) => this.tagData(t).value);
        if (
          (t.inputType == "deleteContentBackward" &&
            u() &&
            this.events.callbacks.onKeydown.call(this, {
              target: t.target,
              key: "Backspace",
            }),
          this.value.slice().forEach((t) => {
            t.readonly &&
              !v.includes(t.value) &&
              c.appendChild(this.createTagElem(t));
          }),
          c.childNodes.length &&
            (m.insertNode(c), this.setRangeAtStartEnd(!1, c.lastChild)),
          p.length != h)
        )
          return (
            (this.value = [].map.call(this.getTagElms(), (t) =>
              this.tagData(t)
            )),
            void this.update({ withoutChangeEvent: !0 })
          );
        if (this.hasMaxTags()) return !0;
        if (
          window.getSelection &&
          (o = window.getSelection()).rangeCount > 0 &&
          o.anchorNode.nodeType == 3
        ) {
          if (
            ((m = o.getRangeAt(0).cloneRange()).collapse(!0),
            m.setStart(o.focusNode, 0),
            (s =
              (e = m.toString().slice(0, m.endOffset)).split(d.pattern).length -
              1),
            (i = e.match(d.pattern)) &&
              (a = e.slice(e.lastIndexOf(i[i.length - 1]))),
            a)
          ) {
            if (
              ((this.state.actions.ArrowLeft = !1),
              (this.state.tag = {
                prefix: a.match(d.pattern)[0],
                value: a.replace(d.pattern, ""),
              }),
              (this.state.tag.baseOffset =
                o.baseOffset - this.state.tag.value.length),
              (l = this.state.tag.value.match(d.delimiters)))
            )
              return (
                (this.state.tag.value = this.state.tag.value.replace(
                  d.delimiters,
                  ""
                )),
                (this.state.tag.delimiters = l[0]),
                this.addTags(this.state.tag.value, d.dropdown.clearOnSelect),
                void this.dropdown.hide()
              );
            n = this.state.tag.value.length >= d.dropdown.enabled;
            try {
              (r =
                (r = this.state.flaggedTags[this.state.tag.baseOffset])
                  .prefix == this.state.tag.prefix &&
                r.value[0] == this.state.tag.value[0]),
                this.state.flaggedTags[this.state.tag.baseOffset] &&
                  !this.state.tag.value &&
                  delete this.state.flaggedTags[this.state.tag.baseOffset];
            } catch (t) {}
            (r || s < this.state.mixMode.matchedPatternCount) && (n = !1);
          } else this.state.flaggedTags = {};
          this.state.mixMode.matchedPatternCount = s;
        }
        setTimeout(() => {
          this.update({ withoutChangeEvent: !0 }),
            this.trigger(
              "input",
              g({}, this.state.tag, { textContent: this.DOM.input.textContent })
            ),
            this.state.tag &&
              this.dropdown[n ? "show" : "hide"](this.state.tag.value);
        }, 10);
      },
      onInputIE(t) {
        const e = this;
        setTimeout(function () {
          e.events.callbacks.onInput.call(e, t);
        });
      },
      observeOriginalInputValue() {
        this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue &&
          this.loadOriginalValues();
      },
      onClickScope(t) {
        const e = this.settings;
        const i = t.target.closest("." + e.classNames.tag);
        const s = +new Date() - this.state.hasFocus;
        if (t.target != this.DOM.scope) {
          if (!t.target.classList.contains(e.classNames.tagX))
            return i
              ? (this.trigger("click", {
                  tag: i,
                  index: this.getNodeIndex(i),
                  data: this.tagData(i),
                  originalEvent: this.cloneEvent(t),
                }),
                void (
                  (e.editTags !== 1 && e.editTags.clicks !== 1) ||
                  this.events.callbacks.onDoubleClickScope.call(this, t)
                ))
              : void (t.target == this.DOM.input &&
                (e.mode == "mix" && this.fixFirefoxLastTagNoCaret(), s > 500)
                  ? this.state.dropdown.visible
                    ? this.dropdown.hide()
                    : e.dropdown.enabled === 0 &&
                      e.mode != "mix" &&
                      this.dropdown.show(this.value.length ? "" : void 0)
                  : e.mode == "select" &&
                    !this.state.dropdown.visible &&
                    this.dropdown.show());
          this.removeTags(t.target.parentNode);
        } else this.state.hasFocus || this.DOM.input.focus();
      },
      onPaste(t) {
        t.preventDefault();
        let e;
        let i;
        const s = this.settings;
        if ((s.mode == "select" && s.enforceWhitelist) || !s.userInput)
          return !1;
        s.readonly ||
          ((e = t.clipboardData || window.clipboardData),
          (i = e.getData("Text")),
          s.hooks
            .beforePaste(t, { tagify: this, pastedText: i, clipboardData: e })
            .then((e) => {
              void 0 === e && (e = i),
                e &&
                  (this.injectAtCaret(e, window.getSelection().getRangeAt(0)),
                  this.settings.mode == "mix"
                    ? this.events.callbacks.onMixTagsInput.call(this, t)
                    : this.settings.pasteAsTags
                    ? this.addTags(this.state.inputText + e, !0)
                    : (this.state.inputText = e));
            })
            .catch((t) => t));
      },
      onDrop(t) {
        t.preventDefault();
      },
      onEditTagInput(t, e) {
        const i = t.closest("." + this.settings.classNames.tag);
        const s = this.getNodeIndex(i);
        const a = this.tagData(i);
        const n = this.input.normalize.call(this, t);
        const o = i.innerHTML != i.__tagifyTagData.__originalHTML;
        let r = this.validateTag(
          g(i.__tagifyTagData, { [this.settings.tagTextProp]: n })
        );
        o || !0 !== t.originalIsValid || (r = !0),
          i.classList.toggle(this.settings.classNames.tagInvalid, !0 !== r),
          (a.__isValid = r),
          (i.title = !0 === r ? a.title || a.value : r),
          n.length >= this.settings.dropdown.enabled &&
            (this.state.editing && (this.state.editing.value = n),
            this.dropdown.show(n)),
          this.trigger("edit:input", {
            tag: i,
            index: s,
            data: g({}, this.value[s], { newValue: n }),
            originalEvent: this.cloneEvent(e),
          });
      },
      onEditTagFocus(t) {
        this.state.editing = {
          scope: t,
          input: t.querySelector("[contenteditable]"),
        };
      },
      onEditTagBlur(t) {
        if (
          (this.state.hasFocus || this.toggleFocusClass(),
          this.DOM.scope.contains(t))
        ) {
          let e;
          let i;
          const s = this.settings;
          const a = t.closest("." + s.classNames.tag);
          const n = this.input.normalize.call(this, t);
          const o = this.tagData(a).__originalData;
          const r = a.innerHTML != a.__tagifyTagData.__originalHTML;
          let l = this.validateTag({ [s.tagTextProp]: n });
          if (n)
            if (r) {
              if (
                ((e = this.hasMaxTags()),
                (i = g({}, o, {
                  [s.tagTextProp]: this.trim(n),
                  value: n,
                  __isValid: l,
                })),
                s.transformTag.call(this, i, o),
                !0 !== (l = (!e || !0 === o.__isValid) && this.validateTag(i)))
              ) {
                if (
                  (this.trigger("invalid", { data: i, tag: a, message: l }),
                  s.editTags.keepInvalid)
                )
                  return;
                s.keepInvalidTags ? (i.__isValid = l) : (i = o);
              } else
                s.keepInvalidTags &&
                  (delete i.title, delete i["aria-invalid"], delete i.class);
              this.onEditTagDone(a, i);
            } else this.onEditTagDone(a, o);
          else this.onEditTagDone(a);
        }
      },
      onEditTagkeydown(t, e) {
        switch (
          (this.trigger("edit:keydown", { originalEvent: this.cloneEvent(t) }),
          t.key)
        ) {
          case "Esc":
          case "Escape":
            e.innerHTML = e.__tagifyTagData.__originalHTML;
          case "Enter":
          case "Tab":
            t.preventDefault(), t.target.blur();
        }
      },
      onDoubleClickScope(t) {
        let e;
        let i;
        const s = t.target.closest("." + this.settings.classNames.tag);
        const a = this.settings;
        s &&
          a.userInput &&
          ((e = s.classList.contains(this.settings.classNames.tagEditing)),
          (i = s.hasAttribute("readonly")),
          a.mode == "select" ||
            a.readonly ||
            e ||
            i ||
            !this.settings.editTags ||
            this.editTag(s),
          this.toggleFocusClass(!0),
          this.trigger("dblclick", {
            tag: s,
            index: this.getNodeIndex(s),
            data: this.tagData(s),
          }));
      },
      onInputDOMChange(t) {
        t.forEach((t) => {
          t.addedNodes.forEach((t) => {
            if (t)
              if (t.outerHTML == "<div><br></div>")
                t.replaceWith(document.createElement("br"));
              else if (
                t.nodeType == 1 &&
                t.querySelector(this.settings.classNames.tagSelector)
              ) {
                let e = document.createTextNode("");
                t.childNodes[0].nodeType == 3 &&
                  t.previousSibling.nodeName != "BR" &&
                  (e = document.createTextNode("\n")),
                  t.replaceWith(e, ...[...t.childNodes].slice(0, -1)),
                  this.placeCaretAfterNode(e.previousSibling);
              } else
                v.call(this, t) &&
                  t.previousSibling &&
                  t.previousSibling.nodeName == "BR" &&
                  (t.previousSibling.replaceWith("\n"),
                  this.placeCaretAfterNode(t.previousSibling.previousSibling));
          }),
            t.removedNodes.forEach((t) => {
              t &&
                t.nodeName == "BR" &&
                v.call(this, e) &&
                (this.removeTags(e), this.fixFirefoxLastTagNoCaret());
            });
        });
        var e = this.DOM.input.lastChild;
        e && e.nodeValue == "" && e.remove(),
          (e && e.nodeName == "BR") ||
            this.DOM.input.appendChild(document.createElement("br"));
      },
    },
  };
  function M(t, e) {
    if (!t) {
      console.warn("Tagify:", "input element not found", t);
      const e = new Proxy(this, { get: () => () => e });
      return e;
    }
    if (
      t.previousElementSibling &&
      t.previousElementSibling.classList.contains("tagify")
    )
      return (
        console.warn("Tagify: ", "input element is already Tagified", t), this
      );
    let i;
    g(
      this,
      (function (t) {
        const e = document.createTextNode("");
        function i(t, i, s) {
          s &&
            i
              .split(/\s+/g)
              .forEach((i) => e[t + "EventListener"].call(e, i, s));
        }
        return {
          off(t, e) {
            return i("remove", t, e), this;
          },
          on(t, e) {
            return e && typeof e === "function" && i("add", t, e), this;
          },
          trigger(i, s, a) {
            let n;
            if (((a = a || { cloneData: !0 }), i))
              if (t.settings.isJQueryPlugin)
                i == "remove" && (i = "removeTag"),
                  jQuery(t.DOM.originalInput).triggerHandler(i, [s]);
              else {
                try {
                  let o = typeof s === "object" ? s : { value: s };
                  if (
                    (((o = a.cloneData ? g({}, o) : o).tagify = this),
                    s instanceof Object)
                  )
                    for (const r in s)
                      s[r] instanceof HTMLElement && (o[r] = s[r]);
                  n = new CustomEvent(i, { detail: o });
                } catch (t) {
                  console.warn(t);
                }
                e.dispatchEvent(n);
              }
          },
        };
      })(this)
    ),
      (this.isFirefox = typeof InstallTrigger !== "undefined"),
      (this.isIE = window.document.documentMode),
      (e = e || {}),
      (this.getPersistedData =
        ((i = e.id),
        (t) => {
          let e;
          const s = "/" + t;
          if (localStorage.getItem(b + i + "/v", 1) == 1)
            try {
              e = JSON.parse(localStorage[b + i + s]);
            } catch (t) {}
          return e;
        })),
      (this.setPersistedData = ((t) =>
        t
          ? (localStorage.setItem(b + t + "/v", 1),
            (e, i) => {
              const s = "/" + i;
              const a = JSON.stringify(e);
              e &&
                i &&
                (localStorage.setItem(b + t + s, a),
                dispatchEvent(new Event("storage")));
            })
          : () => {})(e.id)),
      (this.clearPersistedData = ((t) => (e) => {
        const i = b + "/" + t + "/";
        if (e) localStorage.removeItem(i + e);
        else
          for (const t in localStorage)
            t.includes(i) && localStorage.removeItem(t);
      })(e.id)),
      this.applySettings(t, e),
      (this.state = {
        inputText: "",
        editing: !1,
        actions: {},
        mixMode: {},
        dropdown: {},
        flaggedTags: {},
      }),
      (this.value = []),
      (this.listeners = {}),
      (this.DOM = {}),
      this.build(t),
      T.call(this),
      this.getCSSVars(),
      this.loadOriginalValues(),
      this.events.customBinding.call(this),
      this.events.binding.call(this),
      t.autofocus && this.DOM.input.focus();
  }
  return (
    (M.prototype = {
      _dropdown: w,
      helpers: {
        sameStr: s,
        removeCollectionProp: a,
        omit: n,
        isObject: h,
        parseHTML: r,
        escapeHTML: d,
        extend: g,
        concatWithoutDups: p,
        getUID: m,
        isNodeTag: v,
      },
      customEventsList: [
        "change",
        "add",
        "remove",
        "invalid",
        "input",
        "click",
        "keydown",
        "focus",
        "blur",
        "edit:input",
        "edit:beforeUpdate",
        "edit:updated",
        "edit:start",
        "edit:keydown",
        "dropdown:show",
        "dropdown:hide",
        "dropdown:select",
        "dropdown:updated",
        "dropdown:noMatch",
        "dropdown:scroll",
      ],
      dataProps: [
        "__isValid",
        "__removed",
        "__originalData",
        "__originalHTML",
        "__tagId",
      ],
      trim(t) {
        return this.settings.trim && t && typeof t === "string" ? t.trim() : t;
      },
      parseHTML: r,
      templates: D,
      parseTemplate(t, e) {
        return (
          (t = this.settings.templates[t] || t),
          this.parseHTML(t.apply(this, e))
        );
      },
      set whitelist(t) {
        const e = t && Array.isArray(t);
        (this.settings.whitelist = e ? t : []),
          this.setPersistedData(e ? t : [], "whitelist");
      },
      get whitelist() {
        return this.settings.whitelist;
      },
      applySettings(t, i) {
        f.templates = this.templates;
        const s = (this.settings = g({}, f, i));
        (s.disabled = t.hasAttribute("disabled")),
          (s.readonly = s.readonly || t.hasAttribute("readonly")),
          (s.placeholder = d(
            t.getAttribute("placeholder") || s.placeholder || ""
          )),
          (s.required = t.hasAttribute("required"));
        for (const t in s.classNames)
          Object.defineProperty(s.classNames, t + "Selector", {
            get() {
              return "." + this[t].split(" ")[0];
            },
          });
        if (
          (this.isIE && (s.autoComplete = !1),
          ["whitelist", "blacklist"].forEach((e) => {
            let i = t.getAttribute("data-" + e);
            i && (i = i.split(s.delimiters)) instanceof Array && (s[e] = i);
          }),
          "autoComplete" in i &&
            !h(i.autoComplete) &&
            ((s.autoComplete = f.autoComplete),
            (s.autoComplete.enabled = i.autoComplete)),
          s.mode == "mix" &&
            ((s.autoComplete.rightKey = !0),
            (s.delimiters = i.delimiters || null),
            s.tagTextProp &&
              !s.dropdown.searchKeys.includes(s.tagTextProp) &&
              s.dropdown.searchKeys.push(s.tagTextProp)),
          t.pattern)
        )
          try {
            s.pattern = new RegExp(t.pattern);
          } catch (t) {}
        if (this.settings.delimiters)
          try {
            s.delimiters = new RegExp(this.settings.delimiters, "g");
          } catch (t) {}
        s.disabled && (s.userInput = !1),
          (this.TEXTS = e(e({}, x), s.texts || {})),
          (s.mode != "select" && s.userInput) || (s.dropdown.enabled = 0),
          (s.dropdown.appendTarget =
            i.dropdown && i.dropdown.appendTarget
              ? i.dropdown.appendTarget
              : document.body);
        const a = this.getPersistedData("whitelist");
        Array.isArray(a) &&
          (this.whitelist = Array.isArray(s.whitelist) ? p(s.whitelist, a) : a);
      },
      getAttributes(t) {
        let e;
        const i = this.getCustomAttributes(t);
        let s = "";
        for (e in i) s += " " + e + (void 0 !== t[e] ? `="${i[e]}"` : "");
        return s;
      },
      getCustomAttributes(t) {
        if (!h(t)) return "";
        let e;
        const i = {};
        for (e in t)
          e.slice(0, 2) != "__" &&
            e != "class" &&
            t.hasOwnProperty(e) &&
            void 0 !== t[e] &&
            (i[e] = d(t[e]));
        return i;
      },
      setStateSelection() {
        const t = window.getSelection();
        const e = {
          anchorOffset: t.anchorOffset,
          anchorNode: t.anchorNode,
          range: t.getRangeAt && t.rangeCount && t.getRangeAt(0),
        };
        return (this.state.selection = e), e;
      },
      getCaretGlobalPosition() {
        const t = document.getSelection();
        if (t.rangeCount) {
          const e = t.getRangeAt(0);
          const i = e.startContainer;
          const s = e.startOffset;
          let a, n;
          if (s > 0)
            return (
              (n = document.createRange()),
              n.setStart(i, s - 1),
              n.setEnd(i, s),
              (a = n.getBoundingClientRect()),
              { left: a.right, top: a.top, bottom: a.bottom }
            );
          if (i.getBoundingClientRect) return i.getBoundingClientRect();
        }
        return { left: -9999, top: -9999 };
      },
      getCSSVars() {
        const t = getComputedStyle(this.DOM.scope, null);
        let e;
        this.CSSVars = {
          tagHideTransition: (({ value: t, unit: e }) =>
            e == "s" ? 1e3 * t : t)(
            (function (t) {
              if (!t) return {};
              const e = (t = t.trim().split(" ")[0])
                .split(/\d+/g)
                .filter((t) => t)
                .pop()
                .trim();
              return {
                value: +t
                  .split(e)
                  .filter((t) => t)[0]
                  .trim(),
                unit: e,
              };
            })(((e = "tag-hide-transition"), t.getPropertyValue("--" + e)))
          ),
        };
      },
      build(t) {
        const e = this.DOM;
        this.settings.mixMode.integrated
          ? ((e.originalInput = null), (e.scope = t), (e.input = t))
          : ((e.originalInput = t),
            (e.originalInput_tabIndex = t.tabIndex),
            (e.scope = this.parseTemplate("wrapper", [t, this.settings])),
            (e.input = e.scope.querySelector(
              this.settings.classNames.inputSelector
            )),
            t.parentNode.insertBefore(e.scope, t),
            (t.tabIndex = -1));
      },
      destroy() {
        this.events.unbindGlobal.call(this),
          this.DOM.scope.parentNode.removeChild(this.DOM.scope),
          (this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex),
          this.dropdown.hide(!0),
          clearTimeout(this.dropdownHide__bindEventsTimeout);
      },
      loadOriginalValues(t) {
        let e;
        const i = this.settings;
        if (((this.state.blockChangeEvent = !0), void 0 === t)) {
          const e = this.getPersistedData("value");
          t =
            e && !this.DOM.originalInput.value
              ? e
              : i.mixMode.integrated
              ? this.DOM.input.textContent
              : this.DOM.originalInput.value;
        }
        if ((this.removeAllTags(), t))
          if (i.mode == "mix")
            this.parseMixTags(this.trim(t)),
              ((e = this.DOM.input.lastChild) && e.tagName == "BR") ||
                this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
          else {
            try {
              JSON.parse(t) instanceof Array && (t = JSON.parse(t));
            } catch (t) {}
            this.addTags(t).forEach(
              (t) => t && t.classList.add(i.classNames.tagNoAnimation)
            );
          }
        else this.postUpdate();
        (this.state.lastOriginalValueReported = i.mixMode.integrated
          ? ""
          : this.DOM.originalInput.value),
          (this.state.blockChangeEvent = !1);
      },
      cloneEvent(t) {
        const e = {};
        for (const i in t) e[i] = t[i];
        return e;
      },
      loading(t) {
        return (
          (this.state.isLoading = t),
          this.DOM.scope.classList[t ? "add" : "remove"](
            this.settings.classNames.scopeLoading
          ),
          this
        );
      },
      tagLoading(t, e) {
        return (
          t &&
            t.classList[e ? "add" : "remove"](
              this.settings.classNames.tagLoading
            ),
          this
        );
      },
      toggleClass(t, e) {
        typeof t === "string" && this.DOM.scope.classList.toggle(t, e);
      },
      toggleFocusClass(t) {
        this.toggleClass(this.settings.classNames.focus, !!t);
      },
      triggerChangeEvent: function () {
        if (!this.settings.mixMode.integrated) {
          const t = this.DOM.originalInput;
          const e = this.state.lastOriginalValueReported !== t.value;
          const i = new CustomEvent("change", { bubbles: !0 });
          e &&
            ((this.state.lastOriginalValueReported = t.value),
            (i.simulated = !0),
            t._valueTracker && t._valueTracker.setValue(Math.random()),
            t.dispatchEvent(i),
            this.trigger("change", this.state.lastOriginalValueReported),
            (t.value = this.state.lastOriginalValueReported));
        }
      },
      events: O,
      fixFirefoxLastTagNoCaret() {},
      placeCaretAfterNode(t) {
        if (t && t.parentNode) {
          const e = t.nextSibling;
          const i = window.getSelection();
          const s = i.getRangeAt(0);
          i.rangeCount &&
            (s.setStartAfter(e || t),
            s.collapse(!0),
            i.removeAllRanges(),
            i.addRange(s));
        }
      },
      insertAfterTag(t, e) {
        if (
          ((e = e || this.settings.mixMode.insertAfterTag),
          t && t.parentNode && e)
        )
          return (
            (e = typeof e === "string" ? document.createTextNode(e) : e),
            t.parentNode.insertBefore(e, t.nextSibling),
            e
          );
      },
      editTag(t, e) {
        (t = t || this.getLastTag()), (e = e || {}), this.dropdown.hide();
        const i = this.settings;
        function s() {
          return t.querySelector(i.classNames.tagTextSelector);
        }
        const a = s();
        const n = this.getNodeIndex(t);
        const o = this.tagData(t);
        const r = this.events.callbacks;
        const l = this;
        let d = !0;
        if (a) {
          if (!(o instanceof Object && "editable" in o) || o.editable)
            return (
              a.setAttribute("contenteditable", !0),
              t.classList.add(i.classNames.tagEditing),
              this.tagData(t, {
                __originalData: g({}, o),
                __originalHTML: t.innerHTML,
              }),
              a.addEventListener("focus", r.onEditTagFocus.bind(this, t)),
              a.addEventListener("blur", function () {
                setTimeout(() => r.onEditTagBlur.call(l, s()));
              }),
              a.addEventListener("input", r.onEditTagInput.bind(this, a)),
              a.addEventListener("keydown", (e) =>
                r.onEditTagkeydown.call(this, e, t)
              ),
              a.focus(),
              this.setRangeAtStartEnd(!1, a),
              e.skipValidation || (d = this.editTagToggleValidity(t)),
              (a.originalIsValid = d),
              this.trigger("edit:start", {
                tag: t,
                index: n,
                data: o,
                isValid: d,
              }),
              this
            );
        } else
          console.warn(
            "Cannot find element in Tag template: .",
            i.classNames.tagTextSelector
          );
      },
      editTagToggleValidity(t, e) {
        let i;
        if ((e = e || this.tagData(t)))
          return (
            (i = !("__isValid" in e) || !0 === e.__isValid) ||
              this.removeTagsFromValue(t),
            this.update(),
            t.classList.toggle(this.settings.classNames.tagNotAllowed, !i),
            e.__isValid
          );
        console.warn("tag has no data: ", t, e);
      },
      onEditTagDone(t, e) {
        e = e || {};
        const i = {
          tag: (t = t || this.state.editing.scope),
          index: this.getNodeIndex(t),
          previousData: this.tagData(t),
          data: e,
        };
        this.trigger("edit:beforeUpdate", i, { cloneData: !1 }),
          (this.state.editing = !1),
          delete e.__originalData,
          delete e.__originalHTML,
          t && e[this.settings.tagTextProp]
            ? ((t = this.replaceTag(t, e)),
              this.editTagToggleValidity(t, e),
              this.settings.a11y.focusableTags
                ? t.focus()
                : this.placeCaretAfterNode(t.previousSibling))
            : t && this.removeTags(t),
          this.trigger("edit:updated", i),
          this.dropdown.hide(),
          this.settings.keepInvalidTags && this.reCheckInvalidTags();
      },
      replaceTag(t, e) {
        (e && e.value) || (e = t.__tagifyTagData),
          e.__isValid &&
            e.__isValid != 1 &&
            g(e, this.getInvalidTagAttrs(e, e.__isValid));
        const i = this.createTagElem(e);
        return t.parentNode.replaceChild(i, t), this.updateValueByDOMTags(), i;
      },
      updateValueByDOMTags() {
        (this.value.length = 0),
          [].forEach.call(this.getTagElms(), (t) => {
            t.classList.contains(
              this.settings.classNames.tagNotAllowed.split(" ")[0]
            ) || this.value.push(this.tagData(t));
          }),
          this.update();
      },
      setRangeAtStartEnd(t, e) {
        (t = typeof t === "number" ? t : !!t),
          (e = (e = e || this.DOM.input).lastChild || e);
        const i = document.getSelection();
        try {
          i.rangeCount >= 1 &&
            ["Start", "End"].forEach((s) =>
              i.getRangeAt(0)["set" + s](e, t || e.length)
            );
        } catch (t) {}
      },
      injectAtCaret(t, e) {
        if ((e = e || this.state.selection.range))
          return (
            typeof t === "string" && (t = document.createTextNode(t)),
            e.deleteContents(),
            e.insertNode(t),
            this.setRangeAtStartEnd(!1, t),
            this.updateValueByDOMTags(),
            this.update(),
            this
          );
      },
      input: {
        set(t = "", e = !0) {
          const i = this.settings.dropdown.closeOnSelect;
          (this.state.inputText = t),
            e && (this.DOM.input.innerHTML = d("" + t)),
            !t && i && this.dropdown.hide.bind(this),
            this.input.autocomplete.suggest.call(this),
            this.input.validate.call(this);
        },
        raw() {
          return this.DOM.input.textContent;
        },
        validate() {
          const t =
            !this.state.inputText ||
            !0 === this.validateTag({ value: this.state.inputText });
          return (
            this.DOM.input.classList.toggle(
              this.settings.classNames.inputInvalid,
              !t
            ),
            t
          );
        },
        normalize(t) {
          const e = t || this.DOM.input;
          let i = [];
          e.childNodes.forEach((t) => t.nodeType == 3 && i.push(t.nodeValue)),
            (i = i.join("\n"));
          try {
            i = i.replace(
              /(?:\r\n|\r|\n)/g,
              this.settings.delimiters.source.charAt(0)
            );
          } catch (t) {}
          return (
            (i = i.replace(/\s/g, " ")),
            this.settings.trim && (i = i.replace(/^\s+/, "")),
            this.trim(i)
          );
        },
        autocomplete: {
          suggest(t) {
            if (this.settings.autoComplete.enabled) {
              typeof (t = t || {}) === "string" && (t = { value: t });
              const e = t.value ? "" + t.value : "";
              const i = e.substr(0, this.state.inputText.length).toLowerCase();
              const s = e.substring(this.state.inputText.length);
              e &&
              this.state.inputText &&
              i == this.state.inputText.toLowerCase()
                ? (this.DOM.input.setAttribute("data-suggest", s),
                  (this.state.inputSuggestion = t))
                : (this.DOM.input.removeAttribute("data-suggest"),
                  delete this.state.inputSuggestion);
            }
          },
          set(t) {
            const e = this.DOM.input.getAttribute("data-suggest");
            const i = t || (e ? this.state.inputText + e : null);
            return (
              !!i &&
              (this.settings.mode == "mix"
                ? this.replaceTextWithNode(
                    document.createTextNode(this.state.tag.prefix + i)
                  )
                : (this.input.set.call(this, i), this.setRangeAtStartEnd()),
              this.input.autocomplete.suggest.call(this),
              this.dropdown.hide(),
              !0)
            );
          },
        },
      },
      getTagIdx(t) {
        return this.value.findIndex((e) => e.__tagId == (t || {}).__tagId);
      },
      getNodeIndex(t) {
        let e = 0;
        if (t) for (; (t = t.previousElementSibling); ) e++;
        return e;
      },
      getTagElms(...t) {
        const e =
          "." + [...this.settings.classNames.tag.split(" "), ...t].join(".");
        return [].slice.call(this.DOM.scope.querySelectorAll(e));
      },
      getLastTag() {
        const t = this.DOM.scope.querySelectorAll(
          `${this.settings.classNames.tagSelector}:not(.${this.settings.classNames.tagHide}):not([readonly])`
        );
        return t[t.length - 1];
      },
      tagData: (t, e, i) =>
        t
          ? (e &&
              (t.__tagifyTagData = i ? e : g({}, t.__tagifyTagData || {}, e)),
            t.__tagifyTagData)
          : (console.warn("tag element doesn't exist", t, e), e),
      isTagDuplicate(t, e, i) {
        const a = this.settings;
        return (
          a.mode != "select" &&
          this.value.reduce(
            (n, o) =>
              s(this.trim("" + t), o.value, e || a.dropdown.caseSensitive) &&
              i != o.__tagId
                ? n + 1
                : n,
            0
          )
        );
      },
      getTagIndexByValue(t) {
        const e = [];
        return (
          this.getTagElms().forEach((i, a) => {
            s(
              this.trim(i.textContent),
              t,
              this.settings.dropdown.caseSensitive
            ) && e.push(a);
          }),
          e
        );
      },
      getTagElmByValue(t) {
        const e = this.getTagIndexByValue(t)[0];
        return this.getTagElms()[e];
      },
      flashTag(t) {
        t &&
          (t.classList.add(this.settings.classNames.tagFlash),
          setTimeout(() => {
            t.classList.remove(this.settings.classNames.tagFlash);
          }, 100));
      },
      isTagBlacklisted(t) {
        return (
          (t = this.trim(t.toLowerCase())),
          this.settings.blacklist.filter((e) => ("" + e).toLowerCase() == t)
            .length
        );
      },
      isTagWhitelisted(t) {
        return !!this.getWhitelistItem(t);
      },
      getWhitelistItem(t, e, i) {
        e = e || "value";
        let a;
        const n = this.settings;
        return (
          (i = i || n.whitelist).some((i) => {
            const o = typeof i === "string" ? i : i[e] || i.value;
            if (s(o, t, n.dropdown.caseSensitive, n.trim))
              return (a = typeof i === "string" ? { value: i } : i), !0;
          }),
          a ||
            e != "value" ||
            n.tagTextProp == "value" ||
            (a = this.getWhitelistItem(t, n.tagTextProp, i)),
          a
        );
      },
      validateTag(t) {
        const e = this.settings;
        const i = "value" in t ? "value" : e.tagTextProp;
        const s = this.trim(t[i] + "");
        return (t[i] + "").trim()
          ? e.pattern && e.pattern instanceof RegExp && !e.pattern.test(s)
            ? this.TEXTS.pattern
            : !e.duplicates &&
              this.isTagDuplicate(s, this.state.editing, t.__tagId)
            ? this.TEXTS.duplicate
            : this.isTagBlacklisted(s) ||
              (e.enforceWhitelist && !this.isTagWhitelisted(s))
            ? this.TEXTS.notAllowed
            : !e.validate || e.validate(t)
          : this.TEXTS.empty;
      },
      getInvalidTagAttrs(t, e) {
        return {
          "aria-invalid": !0,
          class: `${t.class || ""} ${
            this.settings.classNames.tagNotAllowed
          }`.trim(),
          title: e,
        };
      },
      hasMaxTags() {
        return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
      },
      setReadonly(t, e) {
        const i = this.settings;
        document.activeElement.blur(),
          (i[e || "readonly"] = t),
          this.DOM.scope[(t ? "set" : "remove") + "Attribute"](
            e || "readonly",
            !0
          ),
          this.setContentEditable(!t);
      },
      setContentEditable(t) {
        !this.settings.readonly &&
          this.settings.userInput &&
          ((this.DOM.input.contentEditable = t),
          (this.DOM.input.tabIndex = t ? 0 : -1));
      },
      setDisabled(t) {
        this.setReadonly(t, "disabled");
      },
      normalizeTags(t) {
        const e = this.settings;
        const i = e.whitelist;
        const s = e.delimiters;
        const a = e.mode;
        const n = e.tagTextProp;
        e.enforceWhitelist;
        const o = [];
        const r = !!i && i[0] instanceof Object;
        const l = t instanceof Array;
        const d = (t) =>
          (t + "")
            .split(s)
            .filter((t) => t)
            .map((t) => ({ [n]: this.trim(t), value: this.trim(t) }));
        if (
          (typeof t === "number" && (t = t.toString()), typeof t === "string")
        ) {
          if (!t.trim()) return [];
          t = d(t);
        } else l && (t = [].concat(...t.map((t) => (t.value ? t : d(t)))));
        return (
          r &&
            (t.forEach((t) => {
              const e = o.map((t) => t.value);
              let i = this.dropdown.filterListItems.call(this, t[n], {
                exact: !0,
              });
              this.settings.duplicates ||
                (i = i.filter((t) => !e.includes(t.value)));
              const s = i.length > 1 ? this.getWhitelistItem(t[n], n, i) : i[0];
              s && s instanceof Object
                ? o.push(s)
                : a != "mix" &&
                  (t.value == null && (t.value = t[n]), o.push(t));
            }),
            o.length && (t = o)),
          t
        );
      },
      parseMixTags(t) {
        const e = this.settings;
        const i = e.mixTagsInterpolator;
        const s = e.duplicates;
        const a = e.transformTag;
        const n = e.enforceWhitelist;
        const o = e.maxTags;
        const r = e.tagTextProp;
        const l = [];
        return (
          (t = t
            .split(i[0])
            .map((t, e) => {
              let d;
              let h;
              let g;
              const p = t.split(i[1]);
              const c = p[0];
              const u = l.length == o;
              try {
                if (c == +c) throw Error;
                h = JSON.parse(c);
              } catch (t) {
                h = this.normalizeTags(c)[0] || { value: c };
              }
              if (
                (a.call(this, h),
                u ||
                  !(p.length > 1) ||
                  (n && !this.isTagWhitelisted(h.value)) ||
                  (!s && this.isTagDuplicate(h.value)))
              ) {
                if (t) return e ? i[0] + t : t;
              } else
                (h[(d = h[r] ? r : "value")] = this.trim(h[d])),
                  (g = this.createTagElem(h)),
                  l.push(h),
                  g.classList.add(this.settings.classNames.tagNoAnimation),
                  (p[0] = g.outerHTML),
                  this.value.push(h);
              return p.join("");
            })
            .join("")),
          (this.DOM.input.innerHTML = t),
          this.DOM.input.appendChild(document.createTextNode("")),
          this.DOM.input.normalize(),
          this.getTagElms().forEach((t, e) => this.tagData(t, l[e])),
          this.update({ withoutChangeEvent: !0 }),
          t
        );
      },
      replaceTextWithNode(t, e) {
        if (this.state.tag || e) {
          e = e || this.state.tag.prefix + this.state.tag.value;
          let i;
          let s;
          const a = window.getSelection();
          const n = a.anchorNode;
          const o = this.state.tag.delimiters
            ? this.state.tag.delimiters.length
            : 0;
          return (
            n.splitText(a.anchorOffset - o),
            (i = n.nodeValue.lastIndexOf(e)) == -1
              ? !0
              : ((s = n.splitText(i)), t && n.parentNode.replaceChild(t, s), !0)
          );
        }
      },
      selectTag(t, e) {
        const i = this.settings;
        if (!i.enforceWhitelist || this.isTagWhitelisted(e.value)) {
          this.input.set.call(this, e[i.tagTextProp] || e.value, !0),
            this.state.actions.selectOption &&
              setTimeout(this.setRangeAtStartEnd.bind(this));
          const s = this.getLastTag();
          return (
            s ? this.replaceTag(s, e) : this.appendTag(t),
            (this.value[0] = e),
            this.update(),
            this.trigger("add", { tag: t, data: e }),
            [t]
          );
        }
      },
      addEmptyTag(t) {
        const e = g({ value: "" }, t || {});
        const i = this.createTagElem(e);
        this.tagData(i, e),
          this.appendTag(i),
          this.editTag(i, { skipValidation: !0 });
      },
      addTags(t, e, i) {
        const s = [];
        const a = this.settings;
        const n = document.createDocumentFragment();
        return (
          (i = i || a.skipInvalid),
          t && t.length != 0
            ? ((t = this.normalizeTags(t)),
              a.mode == "mix"
                ? this.addMixTags(t)
                : (a.mode == "select" && (e = !1),
                  this.DOM.input.removeAttribute("style"),
                  t.forEach((t) => {
                    let e;
                    const o = {};
                    const r = Object.assign({}, t, { value: t.value + "" });
                    if (
                      ((t = Object.assign({}, r)),
                      a.transformTag.call(this, t),
                      (t.__isValid = this.hasMaxTags() || this.validateTag(t)),
                      !0 !== t.__isValid)
                    ) {
                      if (i) return;
                      g(o, this.getInvalidTagAttrs(t, t.__isValid), {
                        __preInvalidData: r,
                      }),
                        t.__isValid == this.TEXTS.duplicate &&
                          this.flashTag(this.getTagElmByValue(t.value));
                    }
                    if (
                      ("readonly" in t &&
                        (t.readonly
                          ? (o["aria-readonly"] = !0)
                          : delete t.readonly),
                      (e = this.createTagElem(t, o)),
                      s.push(e),
                      a.mode == "select")
                    )
                      return this.selectTag(e, t);
                    n.appendChild(e),
                      t.__isValid && !0 === t.__isValid
                        ? (this.value.push(t),
                          this.trigger("add", {
                            tag: e,
                            index: this.value.length - 1,
                            data: t,
                          }))
                        : (this.trigger("invalid", {
                            data: t,
                            index: this.value.length,
                            tag: e,
                            message: t.__isValid,
                          }),
                          a.keepInvalidTags ||
                            setTimeout(() => this.removeTags(e, !0), 1e3)),
                      this.dropdown.position();
                  }),
                  this.appendTag(n),
                  this.update(),
                  t.length && e && this.input.set.call(this),
                  this.dropdown.refilter(),
                  s))
            : (a.mode == "select" && this.removeAllTags(), s)
        );
      },
      addMixTags(t) {
        if ((t = this.normalizeTags(t))[0].prefix || this.state.tag)
          return this.prefixedTextToTag(t[0]);
        typeof t === "string" && (t = [{ value: t }]);
        let e = !!this.state.selection;
        const i = document.createDocumentFragment();
        return (
          t.forEach((t) => {
            const e = this.createTagElem(t);
            i.appendChild(e), this.insertAfterTag(e);
          }),
          e
            ? this.injectAtCaret(i)
            : (this.DOM.input.focus(),
              (e = this.setStateSelection()).range.setStart(
                this.DOM.input,
                e.range.endOffset
              ),
              e.range.setEnd(this.DOM.input, e.range.endOffset),
              this.DOM.input.appendChild(i),
              this.updateValueByDOMTags(),
              this.update()),
          i
        );
      },
      prefixedTextToTag(t) {
        let e;
        const i = this.settings;
        const s = this.state.tag.delimiters;
        if (
          (i.transformTag.call(this, t),
          (t.prefix =
            t.prefix || this.state.tag
              ? this.state.tag.prefix
              : (i.pattern.source || i.pattern)[0]),
          (e = this.createTagElem(t)),
          this.replaceTextWithNode(e) || this.DOM.input.appendChild(e),
          setTimeout(
            () => e.classList.add(this.settings.classNames.tagNoAnimation),
            300
          ),
          this.value.push(t),
          this.update(),
          !s)
        ) {
          const a = this.insertAfterTag(e) || e;
          this.placeCaretAfterNode(a);
        }
        return (
          (this.state.tag = null),
          this.trigger("add", g({}, { tag: e }, { data: t })),
          e
        );
      },
      appendTag(t) {
        const e = this.DOM;
        const i = e.input;
        i === e.input ? e.scope.insertBefore(t, i) : e.scope.appendChild(t);
      },
      createTagElem(t, i) {
        t.__tagId = m();
        let s;
        const a = g({}, t, e({ value: d(t.value + "") }, i));
        return (
          (function (t) {
            for (
              var e,
                i = document.createNodeIterator(
                  t,
                  NodeFilter.SHOW_TEXT,
                  null,
                  !1
                );
              (e = i.nextNode());

            )
              e.textContent.trim() || e.parentNode.removeChild(e);
          })((s = this.parseTemplate("tag", [a]))),
          this.tagData(s, t),
          s
        );
      },
      reCheckInvalidTags() {
        const t = this.settings;
        this.getTagElms(t.classNames.tagNotAllowed).forEach((t, e) => {
          let i = this.tagData(t);
          const s = this.hasMaxTags();
          const a = this.validateTag(i);
          if (!0 === a && !s)
            return (
              (i = i.__preInvalidData
                ? i.__preInvalidData
                : { value: i.value }),
              this.replaceTag(t, i)
            );
          t.title = s || a;
        });
      },
      removeTags(t, e, i) {
        let s;
        if (
          ((t =
            t && t instanceof HTMLElement
              ? [t]
              : t instanceof Array
              ? t
              : t
              ? [t]
              : [this.getLastTag()]),
          (s = t.reduce((t, e) => {
            e && typeof e === "string" && (e = this.getTagElmByValue(e));
            const i = this.tagData(e);
            return (
              e &&
                i &&
                !i.readonly &&
                t.push({
                  node: e,
                  idx: this.getTagIdx(i),
                  data: this.tagData(e, { __removed: !0 }),
                }),
              t
            );
          }, [])),
          (i = typeof i === "number" ? i : this.CSSVars.tagHideTransition),
          this.settings.mode == "select" &&
            ((i = 0), this.input.set.call(this)),
          s.length == 1 &&
            s[0].node.classList.contains(
              this.settings.classNames.tagNotAllowed
            ) &&
            (e = !0),
          s.length)
        )
          return this.settings.hooks
            .beforeRemoveTag(s, { tagify: this })
            .then(() => {
              function t(t) {
                t.node.parentNode &&
                  (t.node.parentNode.removeChild(t.node),
                  e
                    ? this.settings.keepInvalidTags &&
                      this.trigger("remove", { tag: t.node, index: t.idx })
                    : (this.trigger("remove", {
                        tag: t.node,
                        index: t.idx,
                        data: t.data,
                      }),
                      this.dropdown.refilter(),
                      this.dropdown.position(),
                      this.DOM.input.normalize(),
                      this.settings.keepInvalidTags &&
                        this.reCheckInvalidTags()));
              }
              i && i > 10 && s.length == 1
                ? function (e) {
                    (e.node.style.width =
                      parseFloat(window.getComputedStyle(e.node).width) + "px"),
                      document.body.clientTop,
                      e.node.classList.add(this.settings.classNames.tagHide),
                      setTimeout(t.bind(this), i, e);
                  }.call(this, s[0])
                : s.forEach(t.bind(this)),
                e ||
                  (this.removeTagsFromValue(s.map((t) => t.node)),
                  this.update(),
                  this.settings.mode == "select" &&
                    this.setContentEditable(!0));
            })
            .catch((t) => {});
      },
      removeTagsFromDOM() {
        [].slice
          .call(this.getTagElms())
          .forEach((t) => t.parentNode.removeChild(t));
      },
      removeTagsFromValue(t) {
        (t = Array.isArray(t) ? t : [t]).forEach((t) => {
          const e = this.tagData(t);
          const i = this.getTagIdx(e);
          i > -1 && this.value.splice(i, 1);
        });
      },
      removeAllTags(t) {
        (t = t || {}),
          (this.value = []),
          this.settings.mode == "mix"
            ? (this.DOM.input.innerHTML = "")
            : this.removeTagsFromDOM(),
          this.dropdown.position(),
          this.settings.mode == "select" &&
            (this.input.set.call(this), this.setContentEditable(!0)),
          this.update(t);
      },
      postUpdate() {
        const t = this.settings.classNames;
        const e =
          this.settings.mode == "mix"
            ? this.settings.mixMode.integrated
              ? this.DOM.input.textContent
              : this.DOM.originalInput.value.trim()
            : this.value.length + this.input.raw.call(this).length;
        this.toggleClass(
          t.hasMaxTags,
          this.value.length >= this.settings.maxTags
        ),
          this.toggleClass(t.hasNoTags, !this.value.length),
          this.toggleClass(t.empty, !e);
      },
      setOriginalInputValue(t) {
        const e = this.DOM.originalInput;
        this.settings.mixMode.integrated ||
          ((e.value = t),
          (e.tagifyValue = e.value),
          this.setPersistedData(t, "value"));
      },
      update(t) {
        const e = this.getInputValue();
        this.setOriginalInputValue(e),
          this.postUpdate(),
          (t || {}).withoutChangeEvent ||
            this.state.blockChangeEvent ||
            this.triggerChangeEvent();
      },
      getInputValue() {
        const t = this.getCleanValue();
        return this.settings.mode == "mix"
          ? this.getMixedTagsAsString(t)
          : t.length
          ? this.settings.originalInputValueFormat
            ? this.settings.originalInputValueFormat(t)
            : JSON.stringify(t)
          : "";
      },
      getCleanValue(t) {
        return a(t || this.value, this.dataProps);
      },
      getMixedTagsAsString() {
        let t = "";
        const e = this;
        const i = this.settings.mixTagsInterpolator;
        return (
          (function s(a) {
            a.childNodes.forEach((a) => {
              if (a.nodeType == 1) {
                const o = e.tagData(a);
                if (
                  (a.tagName == "BR" && (t += "\r\n"),
                  a.getAttribute("style") ||
                    ["B", "I", "U"].includes(a.tagName))
                )
                  t += a.textContent;
                else if (a.tagName == "DIV" || a.tagName == "P")
                  (t += "\r\n"), s(a);
                else if (v.call(e, a) && o) {
                  if (o.__removed) return;
                  t += i[0] + JSON.stringify(n(o, e.dataProps)) + i[1];
                }
              } else t += a.textContent;
            });
          })(this.DOM.input),
          t
        );
      },
    }),
    (M.prototype.removeTag = M.prototype.removeTags),
    M
  );
});
